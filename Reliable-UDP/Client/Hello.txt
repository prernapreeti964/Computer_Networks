Hello User!!
This is the file that you had requested for.
Enjoy!!!

HTTP functions as a request-response protocol in the client-server computing model. A web browser, for example, may be the client and an application running on a computer hosting a web site may be the server. The client submits an HTTP request message to the server. The server, which provides resources such as HTML files and other content, or performs other functions on behalf of the client, returns a response message to the client. The response contains completion status information about the request and may also contain requested content in its message body.

A web browser is an example of a user agent (UA). Other types of user agent include the indexing software used by search providers (web crawlers), voice browsers, mobile apps, and other software that accesses, consumes, or displays web content.

HTTP is designed to permit intermediate network elements to improve or enable communications between clients and servers. High-traffic websites often benefit from web cache servers that deliver content on behalf of upstream servers to improve response time. Web browsers cache previously accessed web resources and reuse them when possible to reduce network traffic. HTTP proxy servers at private network boundaries can facilitate communication for clients without a globally routable address, by relaying messages with external servers.

HTTP is an application layer protocol designed within the framework of the Internet Protocol Suite. Its definition presumes an underlying and reliable transport layer protocol,[2] and Transmission Control Protocol (TCP) is commonly used. However HTTP can use unreliable protocols such as the User Datagram Protocol (UDP), for example in Simple Service Discovery Protocol (SSDP).

HTTP resources are identified and located on the network by uniform resource locators (URLs), using the uniform resource identifier (URI) schemes http and https. URIs and hyperlinks in Hypertext Markup Language (HTML) documents form inter-linked hypertext documents.

HTTP/1.1 is a revision of the original HTTP (HTTP/1.0). In HTTP/1.0 a separate connection to the same server is made for every resource request. HTTP/1.1 can reuse a connection multiple times to download images, scripts, stylesheets, etc after the page has been delivered. HTTP/1.1 communications therefore experience less latency as the establishment of TCP connections presents considerable overhead.
History
Tim Berners-Lee

The term hypertext was coined by Ted Nelson in 1965 in the Xanadu Project, which was in turn inspired by Vannevar Bush's vision (1930s) of the microfilm-based information retrieval and management "memex" system described in his essay As We May Think (1945). Tim Berners-Lee and his team at CERN are credited with inventing the original HTTP along with HTML and the associated technology for a web server and a text-based web browser. Berners-Lee first proposed the "WorldWideWeb" project in 1989 — now known as the World Wide Web. The first version of the protocol had only one method, namely GET, which would request a page from a server.[3] The response from the server was always an HTML page.[4]

The first documented version of HTTP was HTTP V0.9 (1991). Dave Raggett led the HTTP Working Group (HTTP WG) in 1995 and wanted to expand the protocol with extended operations, extended negotiation, richer meta-information, tied with a security protocol which became more efficient by adding additional methods and header fields.[5][6] RFC 1945 officially introduced and recognized HTTP V1.0 in 1996.

The HTTP WG planned to publish new standards in December 1995[7] and the support for pre-standard HTTP/1.1 based on the then developing RFC 2068 (called HTTP-NG) was rapidly adopted by the major browser developers in early 1996. By March 1996, pre-standard HTTP/1.1 was supported in Arena,[8] Netscape 2.0,[8] Netscape Navigator Gold 2.01,[8] Mosaic 2.7,[citation needed] Lynx 2.5,[citation needed] and in Internet Explorer 2.0.[citation needed] End-user adoption of the new browsers was rapid. In March 1996, one web hosting company reported that over 40% of browsers in use on the Internet were HTTP 1.1 compliant.[citation needed] That same web hosting company reported that by June 1996, 65% of all browsers accessing their servers were HTTP/1.1 compliant.[9] The HTTP/1.1 standard as defined in RFC 2068 was officially released in January 1997. Improvements and updates to the HTTP/1.1 standard were released under RFC 2616 in June 1999.

In 2007, the HTTPbis Working Group was formed, in part, to revise and clarify the HTTP/1.1 specification. In June 2014, the WG released an updated six-part specification obsoleting RFC 2616:

    RFC 7230, HTTP/1.1: Message Syntax and Routing
    RFC 7231, HTTP/1.1: Semantics and Content
    RFC 7232, HTTP/1.1: Conditional Requests
    RFC 7233, HTTP/1.1: Range Requests
    RFC 7234, HTTP/1.1: Caching
    RFC 7235, HTTP/1.1: Authentication

HTTP/2 was published as RFC 7540 in May 2015.
HTTP session

An HTTP session is a sequence of network request-response transactions. An HTTP client initiates a request by establishing a Transmission Control Protocol (TCP) connection to a particular port on a server (typically port 80, occasionally port 8080; see List of TCP and UDP port numbers). An HTTP server listening on that port waits for a client's request message. Upon receiving the request, the server sends back a status line, such as "HTTP/1.1 200 OK", and a message of its own. The body of this message is typically the requested resource, although an error message or other information may also be returned.[1]
HTTP Authentication

HTTP provides multiple authentication schemes such as Basic access authentication and Digest access authentication which operate via a challenge-response mechanism whereby the server identifies and issues a challenge before serving the requested content.

HTTP provides a general framework for access control and authentication, via an extensible set of challenge-response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information.[10]
Authentication Realms

The HTTP Authentication spec also provides an arbitrary, implementation specific construct for further dividing resources common to a given root URI. The realm value string, if present, is combined with the canonical root URI to form the protection space component of the challenge. This in effect allows the server to define separate authentication scopes under one root URI[10]
Request methods
An HTTP 1.1 request made using telnet. The request message, response header section, and response body are highlighted.

HTTP defines methods (sometimes referred to as verbs) to indicate the desired action to be performed on the identified resource. What this resource represents, whether pre-existing data or data that is generated dynamically, depends on the implementation of the server. Often, the resource corresponds to a file or the output of an executable residing on the server. The HTTP/1.0 specification[11] defined the GET, POST and HEAD methods and the HTTP/1.1 specification[12] added 5 new methods: OPTIONS, PUT, DELETE, TRACE and CONNECT. By being specified in these documents their semantics are well known and can be depended upon. Any client can use any method and the server can be configured to support any combination of methods. If a method is unknown to an intermediate it will be treated as an unsafe and non-idempotent method. There is no limit to the number of methods that can be defined and this allows for future methods to be specified without breaking existing infrastructure. For example, WebDAV defined 7 new methods and RFC 5789 specified the PATCH method.

GET
    The GET method requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect. (This is also true of some other HTTP methods.)[1] The W3C has published guidance principles on this distinction, saying, "Web application design should be informed by the above principles, but also by the relevant limitations."[13] See safe methods below.
HEAD
    The HEAD method asks for a response identical to that of a GET request, but without the response body. This is useful for retrieving meta-information written in response headers, without having to transport the entire content.
POST
    The POST method requests that the server accept the entity enclosed in the request as a new subordinate of the web resource identified by the URI. The data POSTed might be, for example, an annotation for existing resources; a message for a bulletin board, newsgroup, mailing list, or comment thread; a block of data that is the result of submitting a web form to a data-handling process; or an item to add to a database.[14]
PUT
    The PUT method requests that the enclosed entity be stored under the supplied URI. If the URI refers to an already existing resource, it is modified; if the URI does not point to an existing resource, then the server can create the resource with that URI.[15]
DELETE
    The DELETE method deletes the specified resource.
TRACE
    The TRACE method echoes the received request so that a client can see what (if any) changes or additions have been made by intermediate servers.
OPTIONS
    The OPTIONS method returns the HTTP methods that the server supports for the specified URL. This can be used to check the functionality of a web server by requesting '*' instead of a specific resource.
CONNECT
    [16] The CONNECT method converts the request connection to a transparent TCP/IP tunnel, usually to facilitate SSL-encrypted communication (HTTPS) through an unencrypted HTTP proxy.[17][18] See HTTP CONNECT tunneling.
PATCH
    The PATCH method applies partial modifications to a resource.[19]

All general-purpose HTTP servers are required to implement at least the GET and HEAD methods,[20] and, whenever possible, also the OPTIONS method.[citation needed]
Safe methods

Some of the methods (for example, HEAD, GET, OPTIONS and TRACE) are, by convention, defined as safe, which means they are intended only for information retrieval and should not change the state of the server. In other words, they should not have side effects, beyond relatively harmless effects such as logging, caching, the serving of banner advertisements or incrementing a web counter. Making arbitrary GET requests without regard to the context of the application's state should therefore be considered safe. However, this is not mandated by the standard, and it is explicitly acknowledged that it cannot be guaranteed.

By contrast, methods such as POST, PUT, DELETE and PATCH are intended for actions that may cause side effects either on the server, or external side effects such as financial transactions or transmission of email. Such methods are therefore not usually used by conforming web robots or web crawlers; some that do not conform tend to make requests without regard to context or consequences.

Despite the prescribed safety of GET requests, in practice their handling by the server is not technically limited in any way. Therefore, careless or deliberate programming can cause non-trivial changes on the server. This is discouraged, because it can cause problems for web caching, search engines and other automated agents, which can make unintended changes on the server.
Idempotent methods and web applications

Methods PUT and DELETE are defined to be idempotent, meaning that multiple identical requests should have the same effect as a single request (note that idempotence refers to the state of the system after the request has completed, so while the action the server takes (e.g. deleting a record) or the response code it returns may be different on subsequent requests, the system state will be the same every time). Methods GET, HEAD, OPTIONS and TRACE, being prescribed as safe, should also be idempotent, as HTTP is a stateless protocol.[1] In contrast, the POST method is not necessarily idempotent, and therefore sending an identical POST request multiple times may further affect state or cause further side effects (such as financial transactions). In some cases this may be desirable, but in other cases this could be due to an accident, such as when a user does not realize that their action will result in sending another request, or they did not receive adequate feedback that their first request was successful. While web browsers may show alert dialog boxes to warn users in some cases where reloading a page may re-submit a POST request, it is generally up to the web application to handle cases where a POST request should not be submitted more than once. Note that whether a method is idempotent is not enforced by the protocol or web server. It is perfectly possible to write a web application in which (for example) a database insert or other non-idempotent action is triggered by a GET or other request. Ignoring this recommendation, however, may result in undesirable consequences, if a user agent assumes that repeating the same request is safe when it isn't.
Security

Implementing methods such as TRACE, TRACK and DEBUG are considered potentially insecure by some security professionals because attackers can use them to gather information or bypass security controls during attacks. Security software tools such as Tenable Nessus and Microsoft UrlScan Security Tool report on the presence of these methods as being security issues.[21] TRACK and DEBUG are not valid HTTP 1.1 verbs.[22]
Status codes
See also: List of HTTP status codes

In HTTP/1.0 and since, the first line of the HTTP response is called the status line and includes a numeric status code (such as "404") and a textual reason phrase (such as "Not Found"). The way the user agent handles the response primarily depends on the code and secondarily on the other response header fields. Custom status codes can be used since, if the user agent encounters a code it does not recognize, it can use the first digit of the code to determine the general class of the response.[23]

The standard reason phrases are only recommendations and can be replaced with "local equivalents" at the web developer's discretion. If the status code indicated a problem, the user agent might display the reason phrase to the user to provide further information about the nature of the problem. The standard also allows the user agent to attempt to interpret the reason phrase, though this might be unwise since the standard explicitly specifies that status codes are machine-readable and reason phrases are human-readable. HTTP status code is primarily divided into five groups for better explanation of request and responses between client and server as named: Informational 1XX, Successful 2XX, Redirection 3XX, Client Error 4XX and Server Error 5XX.
Persistent connections
Main article: HTTP persistent connection

In HTTP/0.9 and 1.0, the connection is closed after a single request/response pair. In HTTP/1.1 a keep-alive-mechanism was introduced, where a connection could be reused for more than one request. Such persistent connections reduce request latency perceptibly, because the client does not need to re-negotiate the TCP 3-Way-Handshake connection after the first request has been sent. Another positive side effect is that in general the connection becomes faster with time due to TCP's slow-start-mechanism.

Version 1.1 of the protocol also made bandwidth optimization improvements to HTTP/1.0. For example, HTTP/1.1 introduced chunked transfer encoding to allow content on persistent connections to be streamed rather than buffered. HTTP pipelining further reduces lag time, allowing clients to send multiple requests before waiting for each response. Another improvement to the protocol was byte serving, where a server transmits just the portion of a resource explicitly requested by a client.
HTTP session state

HTTP is a stateless protocol. A stateless protocol does not require the HTTP server to retain information or status about each user for the duration of multiple requests. However, some web applications implement states or server side sessions using for instance HTTP cookies or Hidden variables within web forms.
Encrypted connections

The most popular way of establishing an encrypted HTTP connection is HTTP Secure.[24] Two other methods for establishing an encrypted HTTP connection also exist: Secure Hypertext Transfer Protocol, and using the HTTP/1.1 Upgrade header to specify an upgrade to TLS. Browser support for these two is, however, nearly non-existent.[25][26][27]
Request message

The request message consists of the following:

    A request line, for example GET /images/logo.png HTTP/1.1, which requests a resource called /images/logo.png from the server.
    Request header fields, such as Accept-Language: en.
    An empty line.
    An optional message body.

The request line and other header fields must each end with <CR><LF> (that is, a carriage return character followed by a line feed character). The empty line must consist of only <CR><LF> and no other whitespace.[28] In the HTTP/1.1 protocol, all header fields except Host are optional.

A request line containing only the path name is accepted by servers to maintain compatibility with HTTP clients before the HTTP/1.0 specification in RFC 1945.[29]
Response message

The response message consists of the following:

    A Status-Line, which include the status code and reason message. (e.g., HTTP/1.1 200 OK, which indicates that the client's request succeeded)
    Response header fields, such as Content-Type: text/html.
    An empty line
    An optional message body

The Status-Line and other header fields must all end with <CR><LF> (a carriage return followed by a line feed). The empty line must consist of only <CR><LF> and no other whitespace.[28]
Example session

Below is a sample conversation between an HTTP client and an HTTP server running on www.example.com, port 80.
Client request

GET /index.html HTTP/1.1
Host: www.example.com

A client request (consisting in this case of the request line and only one header field) is followed by a blank line, so that the request ends with a double newline, each in the form of a carriage return followed by a line feed. The "Host" field distinguishes between various DNS names sharing a single IP address, allowing name-based virtual hosting. While optional in HTTP/1.0, it is mandatory in HTTP/1.1.
Server response

HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
ETag: "3f80f-1b6-3e1cb03b"
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Accept-Ranges: bytes
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>

The ETag (entity tag) header field is used to determine if a cached version of the requested resource is identical to the current version of the resource on the server. Content-Type specifies the Internet media type of the data conveyed by the HTTP message, while Content-Length indicates its length in bytes. The HTTP/1.1 webserver publishes its ability to respond to requests for certain byte ranges of the document by setting the field Accept-Ranges: bytes. This is useful, if the client needs to have only certain portions[30] of a resource sent by the server, which is called byte serving. When Connection: close is sent, it means that the web server will close the TCP connection immediately after the transfer of this response.

Most of the header lines are optional. When Content-Length is missing the length is determined in other ways. Chunked transfer encoding uses a chunk size of 0 to mark the end of the content. Identity encoding without Content-Length reads content until the socket is closed.

A Content-Encoding like gzip can be used to compress the transmitted data.
Similar protocols

The Gopher protocol was a content delivery protocol that was displaced by HTTP in the early 1990s. The protocol SPDY is also similar to HTTP, modifying the request-response interaction between client and server.
See also
HTTP

    Persistence Compression HTTPS 

Request methods

    OPTIONS GET HEAD POST PUT DELETE TRACE CONNECT PATCH 

Header fields

    Cookie ETag Location HTTP referer DNT X-Forwarded-For 

Status codes

    301 Moved Permanently 302 Found 303 See Other 403 Forbidden 404 Not Found 451 Unavailable For Legal Reasons 

    v t e 

    Basic access authentication
    Constrained Application Protocol – A semantically similar protocol to HTTP but used UDP or UDP-like messages targeted for devices with limited processing capability. Re-uses HTTP and other internet concepts like Internet media type and web linking (RFC 5988)[31]
    Content negotiation
    Curl-loader – HTTP/S loading and testing open-source software
    Digest access authentication
    Fiddler (software)
    HTTP compression
    HTTP/2 – developed by the IETF's Hypertext Transfer Protocol Bis (httpbis) working group.[32]
    HTTP-MPLEX – A backwards compatible enhancement to HTTP to improve page and web object retrieval time in congested networks proposed by Robert Mattson
    List of file transfer protocols
    List of HTTP header fields
    List of HTTP status codes
    Representational state transfer (REST)
    Variant object
    Waka (protocol) – An HTTP replacement proposed by Roy Fielding
    Web cache
    WebSocket
    Wireshark

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Simple Mail Transfer Protocol
From Wikipedia, the free encyclopedia
"SMTP" redirects here. For the email delivery company, see SMTP (company).
Internet protocol suite
Application layer

    BGP DHCP DNS FTP HTTP IMAP LDAP MGCP NNTP NTP POP ONC/RPC RTP RTSP RIP SIP SMTP SNMP SSH Telnet TLS/SSL XMPP more... 

Transport layer

    TCP UDP DCCP SCTP RSVP more... 

Internet layer

    IP
        IPv4 IPv6 ICMP ICMPv6 ECN IGMP IPsec more... 

Link layer

    ARP NDP OSPF Tunnels
        L2TP PPP MAC
        Ethernet DSL ISDN FDDI more... 

    v t e 

Internet
Visualization of Internet routing paths
An Opte Project visualization of routing paths through a portion of the Internet
General
[show]
Governance
[show]
Information infrastructure
[hide]

    Domain Name System
    Hypertext Transfer Protocol
    Internet exchange point
    Internet Protocol
    Internet protocol suite
    Internet service provider
    IP address
    Internet Message Access Protocol
    Simple Mail Transfer Protocol

Services
[show]
Guides
[show]
Portal icon Internet portal

    v t e 

Simple Mail Transfer Protocol (SMTP) is an Internet standard for electronic mail (email) transmission. First defined by RFC 821 in 1982, it was last updated in 2008 with the Extended SMTP additions by RFC 5321—which is the protocol in widespread use today.

SMTP by default uses TCP port 25. The protocol for mail submission is the same, but uses port 587. SMTP connections secured by SSL, known as SMTPS, default to port 465 (nonstandard, but sometimes used for legacy reasons).

Although electronic mail servers and other mail transfer agents use SMTP to send and receive mail messages, user-level client mail applications typically use SMTP only for sending messages to a mail server for relaying. For receiving messages, client applications usually use either POP3 or IMAP.

Although proprietary systems (such as Microsoft Exchange and IBM Notes) and webmail systems (such as Outlook.com, Gmail and Yahoo! Mail) use their own non-standard protocols to access mail box accounts on their own mail servers, all use SMTP when sending or receiving email from outside their own systems.

Contents

    1 History
    2 Mail processing model
    3 Protocol overview
        3.1 SMTP vs mail retrieval
        3.2 Remote Message Queue Starting
        3.3 On-Demand Mail Relay
        3.4 Internationalization
    4 Outgoing mail SMTP server
        4.1 Outgoing mail server access restrictions
            4.1.1 Restricting access by location
            4.1.2 Client authentication
            4.1.3 Open relay
        4.2 Ports
    5 SMTP transport example
    6 Optional extensions
    7 Spoofing and spamming
    8 Implementations
    9 Related requests for comments
    10 See also
    11 Notes
    12 References
    13 External links

History

Various forms of one-to-one electronic messaging were used in the 1960s. People communicated with one another using systems developed for specific mainframe computers. As more computers were interconnected, especially in the US Government's ARPANET, standards were developed to allow users of different systems to email one another. SMTP grew out of these standards developed during the 1970s.

SMTP can trace its roots to two implementations described in 1971: the Mail Box Protocol, whose implementation has been disputed,[1] but is discussed in RFC 196 and other RFCs, and the SNDMSG program, which, according to RFC 2235, Ray Tomlinson of BBN invented for TENEX computers to send mail messages across the ARPANET.[2][3][4] Fewer than 50 hosts were connected to the ARPANET at this time.[5]

Further implementations include FTP Mail[6] and Mail Protocol, both from 1973.[7] Development work continued throughout the 1970s, until the ARPANET transitioned into the modern Internet around 1980. Jon Postel then proposed a Mail Transfer Protocol in 1980 that began to remove the mail's reliance on FTP.[8] SMTP was published as RFC 788 in November 1981, also by Postel.

The SMTP standard was developed around the same time as Usenet, a one-to-many communication network with some similarities.

SMTP became widely used in the early 1980s. At the time, it was a complement to Unix to Unix Copy Program (UUCP) mail, which was better suited for handling email transfers between machines that were intermittently connected. SMTP, on the other hand, works best when both the sending and receiving machines are connected to the network all the time. Both use a store and forward mechanism and are examples of push technology. Though Usenet's newsgroups are still propagated with UUCP between servers,[9] UUCP as a mail transport has virtually disappeared[10] along with the "bang paths" it used as message routing headers.[11]

Sendmail, released with 4.1cBSD, right after RFC 788, was one of the first mail transfer agents to implement SMTP.[12] Over time, as BSD Unix became the most popular operating system on the Internet, sendmail became the most common MTA (mail transfer agent).[13] Some other popular SMTP server programs include[chronology citation needed] Postfix, qmail, Novell GroupWise, Exim, Novell NetMail, Microsoft Exchange Server and Oracle Communications Messaging Server.

Message submission (RFC 2476) and SMTP-AUTH (RFC 2554) were introduced in 1998 and 1999, both describing new trends in email delivery. Originally, SMTP servers were typically internal to an organization, receiving mail for the organization from the outside, and relaying messages from the organization to the outside. But as time went on, SMTP servers (mail transfer agents), in practice, were expanding their roles to become message submission agents for Mail user agents, some of which were now relaying mail from the outside of an organization. (e.g. a company executive wishes to send email while on a trip using the corporate SMTP server.) This issue, a consequence of the rapid expansion and popularity of the World Wide Web, meant that SMTP had to include specific rules and methods for relaying mail and authenticating users to prevent abuses such as relaying of unsolicited email (spam). Work on message submission (RFC 2476) was originally started because popular mail servers would often rewrite mail in an attempt to fix problems in it, for example, adding a domain name to an unqualified address. This behavior is helpful when the message being fixed is an initial submission, but dangerous and harmful when the message originated elsewhere and is being relayed. Cleanly separating mail into submission and relay was seen as a way to permit and encourage rewriting submissions while prohibiting rewriting relay. As spam became more prevalent, it was also seen as a way to provide authorization for mail being sent out from an organization, as well as traceability. This separation of relay and submission quickly became a foundation for modern email security practices.

As this protocol started out purely ASCII text-based, it did not deal well with binary files, or characters in many non-English languages. Standards such as Multipurpose Internet Mail Extensions (MIME) were developed to encode binary files for transfer through SMTP. Mail transfer agents (MTAs) developed after Sendmail also tended to be implemented 8-bit-clean, so that the alternate "just send eight" strategy could be used to transmit arbitrary text data (in any 8-bit ASCII-like character encoding) via SMTP. Mojibake was still a problem due to differing character set mappings between vendors, although the email addresses themselves still allowed only ASCII. 8-bit-clean MTAs today tend to support the 8BITMIME extension, permitting binary files to be transmitted almost as easily as plain text. Recently the SMTPUTF8 extension was created to support UTF-8 text, allowing international content and addresses in non-Latin scripts like Cyrillic or Chinese.

Many people contributed to the core SMTP specifications, among them Jon Postel, Eric Allman, Dave Crocker, Ned Freed, Randall Gellens, John Klensin, and Keith Moore.
Mail processing model
Blue arrows can be implemented using SMTP variations.

Email is submitted by a mail client (MUA, mail user agent) to a mail server (MSA, mail submission agent) using SMTP on TCP port 587. Most mailbox providers still allow submission on traditional port 25. From there, the MSA delivers the mail to its mail transfer agent (MTA, mail transfer agent). Often, these two agents are just different instances of the same software launched with different options on the same machine. Local processing can be done either on a single machine, or split among various appliances; in the former case, involved processes can share files; in the latter case, SMTP is used to transfer the message internally, with each host configured to use the next appliance as a smart host. Each process is an MTA in its own right; that is, an SMTP server.

The boundary MTA has to locate the target host. It uses the Domain name system (DNS) to look up the mail exchanger record (MX record) for the recipient's domain (the part of the email address on the right of @). The returned MX record contains the name of the target host. The MTA next connects to the exchange server as an SMTP client. (The article on MX record discusses many factors in determining which server the sending MTA connects to.)

Once the MX target accepts the incoming message, it hands it to a mail delivery agent (MDA) for local mail delivery. An MDA is able to save messages in the relevant mailbox format. Again, mail reception can be done using many computers or just one —the picture displays two nearby boxes in either case. An MDA may deliver messages directly to storage, or forward them over a network using SMTP, or any other means, including the Local Mail Transfer Protocol (LMTP), a derivative of SMTP designed for this purpose.

Once delivered to the local mail server, the mail is stored for batch retrieval by authenticated mail clients (MUAs). Mail is retrieved by end-user applications, called email clients, using Internet Message Access Protocol (IMAP), a protocol that both facilitates access to mail and manages stored mail, or the Post Office Protocol (POP) which typically uses the traditional mbox mail file format or a proprietary system such as Microsoft Exchange/Outlook or Lotus Notes/Domino. Webmail clients may use either method, but the retrieval protocol is often not a formal standard.

SMTP defines message transport, not the message content. Thus, it defines the mail envelope and its parameters, such as the envelope sender, but not the header (except trace information) nor the body of the message itself. STD 10 and RFC 5321 define SMTP (the envelope), while STD 11 and RFC 5322 define the message (header and body), formally referred to as the Internet Message Format.
Protocol overview

SMTP is a connection-oriented, text-based protocol in which a mail sender communicates with a mail receiver by issuing command strings and supplying necessary data over a reliable ordered data stream channel, typically a Transmission Control Protocol (TCP) connection. An SMTP session consists of commands originated by an SMTP client (the initiating agent, sender, or transmitter) and corresponding responses from the SMTP server (the listening agent, or receiver) so that the session is opened, and session parameters are exchanged. A session may include zero or more SMTP transactions. An SMTP transaction consists of three command/reply sequences (see example below.) They are:

    MAIL command, to establish the return address, a.k.a. Return-Path,[14] reverse-path,[15] bounce address, mfrom, or envelope sender. This is the address to which bounce messages should be sent.
    RCPT command, to establish a recipient of this message. This command can be issued multiple times, one for each recipient. These addresses are also part of the envelope.
    DATA to signal the beginning of the message text; the content of the message, as opposed to its envelope. It consists of a message header and a message body separated by an empty line. DATA is actually a group of commands, and the server replies twice: once to the DATA command proper, to acknowledge that it is ready to receive the text, and the second time after the end-of-data sequence, to either accept or reject the entire message.

Besides the intermediate reply for DATA, each server's reply can be either positive (2xx reply codes) or negative. Negative replies can be permanent (5xx codes) or transient (4xx codes). A reject is a permanent failure by an SMTP server; in this case the SMTP client should send a bounce message. A drop is a positive response followed by message discard rather than delivery.

The initiating host, the SMTP client, can be either an end-user's email client, functionally identified as a mail user agent (MUA), or a relay server's mail transfer agent (MTA), that is an SMTP server acting as an SMTP client, in the relevant session, in order to relay mail. Fully capable SMTP servers maintain queues of messages for retrying message transmissions that resulted in transient failures.

A MUA knows the outgoing mail SMTP server from its configuration. An SMTP server acting as client, i.e. relaying, typically determines which SMTP server to connect to by looking up the MX (Mail eXchange) DNS resource record for each recipient's domain name. Conformant MTAs (not all) fall back to a simple A record in case no MX record can be found. Relaying servers can also be configured to use a smart host.

An SMTP server acting as client initiates a TCP connection to the server on the "well-known port" designated for SMTP: port 25. MUAs should use port 587 to connect to an MSA. The main difference between an MTA and an MSA is that SMTP Authentication is mandatory for the latter only.
SMTP vs mail retrieval

SMTP is a delivery protocol only. In normal use, mail is "pushed" to a destination mail server (or next-hop mail server) as it arrives. Mail is routed based on the destination server, not the individual user(s) to which it is addressed. Other protocols, such as the Post Office Protocol (POP) and the Internet Message Access Protocol (IMAP) are specifically designed for use by individual users retrieving messages and managing mail boxes. To permit an intermittently-connected mail server to pull messages from a remote server on demand, SMTP has a feature to initiate mail queue processing on a remote server (see Remote Message Queue Starting below). POP and IMAP are unsuitable protocols for relaying mail by intermittently-connected machines; they are designed to operate after final delivery, when information critical to the correct operation of mail relay (the "mail envelope") has been removed.
Remote Message Queue Starting

Remote Message Queue Starting is a feature of SMTP that permits a remote host to start processing of the mail queue on a server so it may receive messages destined to it by sending the TURN command. This feature however was deemed insecure[16] and was extended in RFC 1985 with the ETRN command which operates more securely using an authentication method based on Domain Name System information.
On-Demand Mail Relay
Main article: On-Demand Mail Relay

On-Demand Mail Relay (ODMR) is an SMTP extension standardized in RFC 2645 that allows an intermittently-connected SMTP server to receive email queued for it when it is connected.
Internationalization
Main article: International email

Users whose native script is not Latin based, or who use diacritic not in the ASCII character set have had difficulty with the Latin email address requirement. RFC 6531 was created to solve that problem, providing internationalization features for SMTP, the SMTPUTF8 extension and support for multi-byte and non-ASCII characters in email addresses, such as Pelé@live.com (simple diacritic), δοκιμή@παράδειγμα.δοκιμή, and 测试@测试.测试.

Current support is limited, but there is strong interest in broad adoption of RFC 6531 and the related RFCs in countries like China that have a large user base where Latin (ASCII) is a foreign script.
Outgoing mail SMTP server

An email client needs to know the IP address of its initial SMTP server and this has to be given as part of its configuration (usually given as a DNS name). This server will deliver outgoing messages on behalf of the user.
Outgoing mail server access restrictions

Server administrators need to impose some control on which clients can use the server. This enables them to deal with abuse, for example spam. Two solutions have been in common use:

    In the past, many systems imposed usage restrictions by the location of the client, only permitting usage by clients whose IP address is one that the server administrators control. Usage from any other client IP address is disallowed.
    Modern SMTP servers typically offer an alternative system that requires authentication of clients by credentials before allowing access.

Restricting access by location

Under this system, an ISP's SMTP server will not allow access by users who are outside the ISP's network. More precisely, the server may only allow access to users with an IP address provided by the ISP, which is equivalent to requiring that they are connected to the Internet using that same ISP. A mobile user may often be on a network other than that of their normal ISP, and will then find that sending email fails because the configured SMTP server choice is no longer accessible.

This system has several variations. For example, an organisation's SMTP server may only provide service to users on the same network, enforcing this by firewalling to block access by users on the wider Internet. Or the server may perform range checks on the client's IP address. These methods were typically used by corporations and institutions such as universities which provided an SMTP server for outbound mail only for use internally within the organisation. However, most of these bodies now use client authentication methods, as described below.

By restricting access to certain IP addresses, server administrators can readily recognise the IP address of any abuser. As it will be a meaningful address to them, the administrators can deal with the rogue machine or user.

Where a user is mobile, and may use different ISPs to connect to the internet, this kind of usage restriction is onerous, and altering the configured outbound email SMTP server address is impractical. It is highly desirable to be able to use email client configuration information that does not need to change.
Client authentication

Modern SMTP servers typically require authentication of clients by credentials before allowing access, rather than restricting access by location as described earlier. This more flexible system is friendly to mobile users and allows them to have a fixed choice of configured outbound SMTP server.
Open relay

A server that is accessible on the wider Internet and does not enforce these kinds of access restrictions is known as an open relay. This is now generally considered a bad practice worthy of blacklisting.
Ports

Communication between mail servers generally always uses the standard TCP port 25 designated for SMTP.

Mail clients however generally don't use this, instead using specific "submission" ports. Mail services generally accept email submission from clients on one of:

    587 (Submission), as formalized in RFC 6409 (previously RFC 2476)
    465 This port has been deprecated since RFC 2487, after being briefly assigned for secure SMTP in the 1990s. Despite this, it is commonly used by mail providers[17][18]

Port 2525 and others may be used by some individual providers, but have never been officially supported.

Most Internet service providers now block all outgoing port 25 traffic from their customers as an anti-spam measure.[19][20] For the same reason, businesses will typically configure their firewall to only allow outgoing port 25 traffic from their designated mail servers.
SMTP transport example

A typical example of sending a message via SMTP to two mailboxes (alice and theboss) located in the same mail domain (example.com or localhost.com) is reproduced in the following session exchange. (In this example, the conversation parts are prefixed with S: and C:, for server and client, respectively; these labels are not part of the exchange.)

After the message sender (SMTP client) establishes a reliable communications channel to the message receiver (SMTP server), the session is opened with a greeting by the server, usually containing its fully qualified domain name (FQDN), in this case smtp.example.com. The client initiates its dialog by responding with a HELO command identifying itself in the command's parameter with its FQDN (or an address literal if none is available).[21]

S: 220 smtp.example.com ESMTP Postfix
C: HELO relay.example.org 
S: 250 Hello relay.example.org, I am glad to meet you
C: MAIL FROM:<bob@example.org>
S: 250 Ok
C: RCPT TO:<alice@example.com>
S: 250 Ok
C: RCPT TO:<theboss@example.com>
S: 250 Ok
C: DATA
S: 354 End data with <CR><LF>.<CR><LF>
C: From: "Bob Example" <bob@example.org>
C: To: "Alice Example" <alice@example.com>
C: Cc: theboss@example.com
C: Date: Tue, 15 January 2008 16:02:43 -0500
C: Subject: Test message
C: 
C: Hello Alice.
C: This is a test message with 5 header fields and 4 lines in the message body.
C: Your friend,
C: Bob
C: .
S: 250 Ok: queued as 12345
C: QUIT
S: 221 Bye
{The server closes the connection}

The client notifies the receiver of the originating email address of the message in a MAIL FROM command. In this example, the email message is sent to two mailboxes on the same SMTP server: one for each recipient listed in the To and Cc header fields. The corresponding SMTP command is RCPT TO. Each successful reception and execution of a command is acknowledged by the server with a result code and response message (e.g., 250 Ok).

The transmission of the body of the mail message is initiated with a DATA command after which it is transmitted verbatim line by line and is terminated with an end-of-data sequence. This sequence consists of a new-line (<CR><LF>), a single full stop (period), followed by another new-line. Since a message body can contain a line with just a period as part of the text, the client sends two periods every time a line starts with a period; correspondingly, the server replaces every sequence of two periods at the beginning of a line with a single one. Such escaping method is called dot-stuffing.

The server's positive reply to the end-of-data, as exemplified, implies that the server has taken the responsibility of delivering the message. A message can be doubled if there is a communication failure at this time, e.g. due to a power shortage: Until the sender has received that 250 reply, it must assume the message was not delivered. On the other hand, after the receiver has decided to accept the message, it must assume the message has been delivered to it. Thus, during this time span, both agents have active copies of the message that they will try to deliver.[22] The probability that a communication failure occurs exactly at this step is directly proportional to the amount of filtering that the server performs on the message body, most often for anti-spam purposes. The limiting timeout is specified to be 10 minutes.[23]

The QUIT command ends the session. If the email has other recipients located elsewhere, the client would QUIT and connect to an appropriate SMTP server for subsequent recipients after the current destination(s) had been queued. The information that the client sends in the HELO and MAIL FROM commands are added (not seen in example code) as additional header fields to the message by the receiving server. It adds a Received and Return-Path header field, respectively.

Some clients are implemented to close the connection after the message is accepted (250 Ok: queued as 12345), so the last two lines may actually be omitted. This causes an error on the server when trying to send the 221 reply.
Optional extensions

Although optional and not shown in this example, many clients ask the server for the SMTP extensions that the server supports, by using the EHLO greeting of the Extended SMTP specification (RFC 1870). Clients fall back to HELO only if the server does not respond to EHLO.

Modern clients may use the ESMTP extension keyword SIZE to query the server for the maximum message size that will be accepted. Older clients and servers may try to transfer excessively sized messages that will be rejected after consuming network resources, including connect time to network links that is paid by the minute.

Users can manually determine in advance the maximum size accepted by ESMTP servers. The client replaces the HELO command with the EHLO command.

S: 220 smtp2.example.com ESMTP Postfix
C: EHLO bob.example.org
S: 250-smtp2.example.com Hello bob.example.org [192.0.2.201]
S: 250-SIZE 14680064
S: 250-PIPELINING
S: 250 HELP

Thus smtp2.example.com declares that it will accept a fixed maximum message size no larger than 14,680,064 octets (8-bit bytes). Depending on the server's actual resource usage, it may be currently unable to accept a message this large.

In the simplest case, an ESMTP server will declare a maximum SIZE immediately after receiving an EHLO. According to RFC 1870, however, the numeric parameter to the SIZE extension in the EHLO response is optional. Clients may instead, when issuing a MAIL FROM command, include a numeric estimate of the size of the message they are transferring, so that the server can refuse receipt of overly-large messages.
Spoofing and spamming
Main article: Anti-spam techniques

The original design of SMTP had no facility to authenticate senders, or check that servers were authorized to send on their behalf, with the result that email spoofing is possible, and commonly used in email spam and phishing.

Occasional proposals are made to modify SMTP extensively or replace it completely. One example of this is Internet Mail 2000, but neither it, nor any other has made much headway in the face of the network effect of the huge installed base of classic SMTP. Instead, mail servers now use a range of techniques, including DomainKeys, DomainKeys Identified Mail, Sender Policy Framework and DMARC, DNSBLs and greylisting to reject or quarantine suspicious emails.
Implementations
Main articles: List of mail servers and Comparison of mail servers
Related requests for comments

    RFC 1123 – Requirements for Internet Hosts—Application and Support (STD 3)
    RFC 1870 – SMTP Service Extension for Message Size Declaration (оbsoletes: RFC 1653)
    RFC 2505 – Anti-Spam Recommendations for SMTP MTAs (BCP 30)
    RFC 2920 – SMTP Service Extension for Command Pipelining (STD 60)
    RFC 3030 – SMTP Service Extensions for Transmission of Large and Binary MIME Messages
    RFC 3207 – SMTP Service Extension for Secure SMTP over Transport Layer Security (obsoletes RFC 2487)
    RFC 3461 – SMTP Service Extension for Delivery Status Notifications (obsoletes RFC 1891)
    RFC 3463 – Enhanced Status Codes for SMTP (obsoletes RFC 1893, updated by RFC 5248)
    RFC 3464 – An Extensible Message Format for Delivery Status Notifications (obsoletes RFC 1894)
    RFC 3798 – Message Disposition Notification (updates RFC 3461)
    RFC 3834 – Recommendations for Automatic Responses to Electronic Mail
    RFC 4952 – Overview and Framework for Internationalized Email (updated by RFC 5336)
    RFC 4954 – SMTP Service Extension for Authentication (obsoletes RFC 2554, updates RFC 3463, updated by RFC 5248)
    RFC 5068 – Email Submission Operations: Access and Accountability Requirements (BCP 134)
    RFC 5248 - A Registry for SMTP Enhanced Mail System Status Codes (BCP 138) (updates RFC 3463)
    RFC 5321 – The Simple Mail Transfer Protocol (obsoletes RFC 821 aka STD 10, RFC 974, RFC 1869, RFC 2821, updates RFC 1123)
    RFC 5322 – Internet Message Format (obsoletes RFC 822 aka STD 11, and RFC 2822)
    RFC 5504 – Downgrading Mechanism for Email Address Internationalization
    RFC 6409 – Message Submission for Mail (STD 72) (obsoletes RFC 4409, RFC 2476)
    RFC 6522 – The Multipart/Report Content Type for the Reporting of Mail System Administrative Messages (obsoletes RFC 3462, and in turn RFC 1892)
    RFC 6531 – SMTP Extension for Internationalized Email Addresses (updates RFC 2821, RFC 2822, RFC 4952, and RFC 5336)

See also

    Bounce address
    Email encryption
    Ident
    POP before SMTP / SMTP after POP
    Sender Policy Framework (SPF)
    Variable envelope return path
    Dkim

Notes

The History of Electronic Mail, Tom Van Vleck: "It is not clear this protocol was ever implemented"
The First Network Email, Ray Tomlinson, BBN
Picture of "The First Email Computer" by Dan Murphy, a PDP-10
Dan Murphy's TENEX and TOPS-20 Papers Archived May 1, 2015 at the Wayback Machine
RFC 2235
RFC 469 – Network Mail Meeting Summary
RFC 524 – A Proposed Mail Protocol
RFC 772 – Mail Transfer Protocol
Tldp.org
draft-barber-uucp-project-conclusion-05 – The Conclusion of the UUCP Mapping Project
The article about sender rewriting contains technical background info about the early SMTP history and source routing before RFC 1123.
Eric Allman (1983), Sendmail – An Internetwork Mail Router (PDF), BSD UNIX documentation set, Berkeley: University of California, retrieved June 29, 2012
Craig Partridge (2008), The Technical Development of Internet Email (PDF), IEEE Annals of the History of Computing, IEEE Computer Society, doi:10.1109/MAHC.2008.32
"The MAIL, RCPT, and DATA verbs", [D. J. Bernstein]
RFC5321 Section-7.2
RFC 1985, SMTP Service Extension for Remote Message Queue Starting, J. De Winter, The Internet Society (August 1996)
[1]
[2]
[3]
They will generally make exceptions for businesses which have legitimate mail servers, and may allow access to their own mail servers
RFC 5321, Simple Mail Transfer Protocol, J. Klensin, The Internet Society (October 2008)
RFC 1047

    rfc5321#section-4.5.3.2.6

References

    Hughes, L (1998). Internet E-mail: Protocols, Standards and Implementation. Artech House Publishers. ISBN 0-89006-939-5.
    Hunt, C (2003). sendmail Cookbook. O'Reilly Media. ISBN 0-596-00471-0.
    Johnson, K (2000). Internet Email Protocols: A Developer's Guide. Addison-Wesley Professional. ISBN 0-201-43288-9.
    Loshin, P (1999). Essential Email Standards: RFCs and Protocols Made Practical. John Wiley & Sons. ISBN 0-471-34597-0.
    Rhoton, J (1999). Programmer's Guide to Internet Mail: SMTP, POP, IMAP, and LDAP. Elsevier. ISBN 1-55558-212-5.
    Wood, D (1999). Programming Internet Mail. O'Reilly. ISBN 1-56592-479-7.

External links

    Email Address Internationalization IETF Working Group

[hide]

    v t e 

Email clients
Free software 	

    Alpine Arachne Balsa Citadel/UX Classilla Claws Mail Columba Cone Cronos II Elm Evolution fetchmail getmail GNUMail Gnus Gnuzilla IMP KMail Mahogany Mailpile Mailx Mailx (Heirloom Project) Modest Mozilla Thunderbird Mulberry Mutt nmh / MH OfflineIMAP Roundcube SeaMonkey sendEmail SquirrelMail Sylpheed Trojitá YAM Zimbra 

Freeware 	

    Denshin 8 go eM Client EmailTray Foxmail Inky i.Scribe Mailbird Opera Mail Windows Live Mail 

Retail 	

    Mail (Windows) Mail (OS X) Bloomba/WordPerfect Mail IBM Notes InScribe Microsoft Outlook Novell GroupWise 

Shareware 	

    Becky! Eureka Email Forté Agent Gemini Net-Tamer Pocomail The Bat! 

Donationware 	

    Pegasus Mail 

Discontinued 	

    Beonex Communicator BlitzMail cc:Mail Claris Emailer Columbia MM Courier Cyberdog Cyberjack Embrowser Eudora Hula Mailody Microsoft Entourage Microsoft Internet Mail and News MINUET Mozilla Mail & Newsgroups Netscape Mail Netscape Messenger 9 NeXTMail Omni Mobile Outlook Express Pine POPmail Sparrow Spicebird Turnpike WebSpyder Windows Mail Windows Messaging 

Related technologies 	

    Extended SMTP IMAP POP Push-IMAP SMAP SMTP UUCP 

Related topics 	

    Email Unicode and email 

    Category Comparison List 

Categories:

    Internet mail protocols

Navigation menu

    Create account
    Not logged in
    Talk
    Contributions
    Log in

    Article
    Talk

    Read
    Edit
    View history

    Main page
    Contents
    Featured content
    Current events
    Random article
    Donate to Wikipedia
    Wikipedia store

Interaction

    Help
    About Wikipedia
    Community portal
    Recent changes
    Contact page

Tools

    What links here
    Related changes
    Upload file
    Special pages
    Permanent link
    Page information
    Wikidata item
    Cite this page

Print/export

    Create a book
    Download as PDF
    Printable version

Languages

    العربية
    Azərbaycanca
    Български
    Bosanski
    Català
    Čeština
    Dansk
    Deutsch
    Eesti
    Ελληνικά
    Español
    Esperanto
    Euskara
    فارسی
    Français
    Galego
    한국어
    Հայերեն
    Hrvatski
    Bahasa Indonesia
    Íslenska
    Italiano
    עברית
    Kurdî
    Latviešu
    Lëtzebuergesch
    Lietuvių
    Magyar
    Македонски
    മലയാളം
    Bahasa Melayu
    Nederlands
    日本語
    Norsk bokmål
    Norsk nynorsk
    Олык марий
    Polski
    Português
    Română
    Русский
    Scots
    Simple English
    Slovenčina
    Slovenščina
    Српски / srpski
    Srpskohrvatski / српскохрватски
    Suomi
    Svenska
    ไทย
    Türkçe
    Українська
    Tiếng Việt
    Yorùbá
    中文

Edit links

    This page was last modified on 19 September 2015, at 07:49.
    Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.

SMTP Authentication
From Wikipedia, the free encyclopedia

SMTP Authentication, often abbreviated SMTP AUTH, is an extension of the Simple Mail Transfer Protocol whereby an SMTP client may log in using an authentication mechanism chosen among those supported by the SMTP server. The authentication extension is mandatory for submission servers.[1]

Contents

    1 History
    2 Role in the mail transport system
    3 Details
    4 Standards
    5 See also
    6 References

History

Differently from mail-access protocols, the original SMTP specified by Jon Postel in the 1970s did not provide for using passwords for sending email messages. This lack of security gave rise to open mail relays, unprotected mail servers used to propagate spam and worms that became a plague in the late '90s.[2] Before SMTP AUTH, a relay client had to be identified by IP address, which is only practical for email services provided by the same Internet service provider (ISP) supplying the connection, or else using specific hacks, such as POP before SMTP.

John Gardiner Myers published the first draft of SMTP AUTH in 1995,[3] and it has been successively developed and discussed in the IETF along with mail submission protocol, Extended SMTP (ESMTP), and Simple Authentication and Security Layer (SASL). An older SASL mechanism for ESMTP authentication (ESMTPA) is CRAM-MD5, and uses of the MD5 algorithm in HMACs (hash-based message authentication codes) are still considered sound.[4]

The Internet Mail Consortium (IMC) reported 55% of mail servers were open relays in 1998,[5] but less than 1% in 2002.[6]
Role in the mail transport system

Using a mail submission agent (MSA), generally on port 587, implies SMTP AUTH. MSA usage is supported by most software[7] and is recommended, especially to support nomadic users, as several network hubs either block port 25 or use SMTP proxies. The MSA is responsible for ensuring that the message envelope contains good addresses, and may enforce local policies for the From header field. Verifying that the envelope sender (a.k.a. Return-Path) used for SPF and the From address agree with the authenticated user-id is particularly important for domains that sign messages using DKIM.

Keywords ending in "A" such as ESMTPA and ESMTPSA, are provided for the with clause of ''Received header fields, when messages are received with SMTP AUTH.[8] "The keywords are provided for statistical or diagnostic purposes" (RFC 3848); they are checked by some clients, e.g. Spamassassin.
Details

As with all SMTP extensions, SMTP AUTH is advertised in the EHLO response, along with a list of supported authentication methods. These methods may change after issuing STARTTLS, typically allowing plain text passwords in the latter case only. For example (from rfc4954):

  S: 220 smtp.example.com ESMTP Server
  C: EHLO client.example.com
  S: 250-smtp.example.com Hello client.example.com
  S: 250-AUTH GSSAPI DIGEST-MD5
  S: 250-ENHANCEDSTATUSCODES
  S: 250 STARTTLS
  C: STARTTLS
  S: 220 Ready to start TLS
    ... TLS negotiation proceeds. 
     Further commands protected by TLS layer ...
  C: EHLO client.example.com
  S: 250-smtp.example.com Hello client.example.com
  S: 250 AUTH GSSAPI DIGEST-MD5 PLAIN
  C: AUTH PLAIN dGVzdAB0ZXN0ADEyMzQ=
  S: 235 2.7.0 Authentication successful

SMTP AUTH can be used also on port 25. Usually, servers reject RCPT TO commands that imply relaying unless authentication credentials have been accepted. The specification recommends that servers issue 530 5.7.0 Authentication required in response to most commands in case the server is configured to require authentication and the client hasn't done it yet. Only servers listening on port 587, or private servers, should be configured that way, not a Message eXchange (MX). However, the historical trait that SMTP is not authenticated by default results in a different behavior with regard to access protocols, in some cases; for example, when using AUTH EXTERNAL after STARTTLS.[9]

Besides the AUTH command, the extension also provides for an AUTH parameter to the MAIL FROM command, so as to allow to distinguish authentication from authorization. That way, a sender can identify itself and transmit several messages during the same session. While the authentication doesn't need to vary, once established, different messages may be sent according to different agreements and hence require different authorization. For example, messages may be relayed on behalf of different users. Use of this parameter is much less popular than using the command to grant relay privileges.

When using authentication, EHLO should be used for the greeting to indicate that Extended SMTP is in use, as opposed to the HELO greeting in standard SMTP.

The capitalized text after the AUTH command is a list of the types of authorization that the SMTP server will accept.

Some examples of authorization protocols include:

    PLAIN (Uses Base64 encoding.)
    LOGIN (Uses Base64 encoding.)
    GSSAPI (Generic Security Services Application Program Interface)
    DIGEST-MD5 (Digest access authentication)
    MD5
    CRAM-MD5

Standards

    RFC 3207, SMTP Service Extension for Secure SMTP over Transport Layer Security, Paul Hoffman, February 2002.
    RFC 3848, ESMTP and LMTP Transmission Types Registration, Chris Newman, July 2004.
    RFC 6409, Message Submission for Mail, Randall Gellens and John C. Klensin, November 2011 (obsoletes RFC 4409, from 2006, which in turn replaced RFC 2476, from December 1998).
    RFC 4422, Simple Authentication and Security Layer (SASL), Alexey Melnikov and Kurt D. Zeilenga, June 2006.
    RFC 4954, SMTP Service Extension for Authentication, Robert Siemborski and Alexey Melnikov, July 2007.

See also

    E-mail authentication
    Simple Mail Transfer Protocol
    Mail submission agent
    Extended SMTP
    Email client port numbers
    Simple Authentication and Security Layer
    Open mail relay
    POP before SMTP

References

The relevant RFCs for reference are specified in the #Standards section
The Trustees of Indiana University (2008-04-01). "In Unix, what is an open mail relay?". University Information Technology Services. Indiana University. Archived from the original on 2007-06-17. Retrieved 2008-04-07.
John Gardiner Myers (April 1995). "SMTP Service Extension for Authentication". IETF. Retrieved 2010-05-30.
Sean Turner, Lily Chen (March 2011). "Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms". IETF.
Paul Hoffman (February 1, 1998). "Allowing Relaying in SMTP: A Survey". Internet Mail Consortium. Retrieved 2010-05-30.
Paul Hoffman (August 2002). "Allowing Relaying in SMTP: A Series of Surveys". Internet Mail Consortium. Retrieved 2010-05-30.
Randall Gellens (January 19, 2005). "Message Submission Interoperability Report". IETF. Retrieved 2010-05-30.
"Mail parameters". IANA registry. Retrieved 2011-07-23.

    Chris Newman (Fri, 30 Apr 2010 16:28:32 -0700). "Interop problem: SMTP submission, STARTTLS, AUTH EXTERNAL". IETF. Retrieved 2010-05-30. Check date values in: |date= (help)

Categories:

    Email authenticationInternet mail protocolsComputer access control protocols

Navigation menu

    Create account
    Not logged in
    Talk
    Contributions
    Log in

    Article
    Talk

    Read
    Edit
    View history

    Main page
    Contents
    Featured content
    Current events
    Random article
    Donate to Wikipedia
    Wikipedia store

Interaction

    Help
    About Wikipedia
    Community portal
    Recent changes
    Contact page

Tools

    What links here
    Related changes
    Upload file
    Special pages
    Permanent link
    Page information
    Wikidata item
    Cite this page

Print/export

    Create a book
    Download as PDF
    Printable version

Languages

    Deutsch
    Français
    Polski

Edit links

    This page was last modified on 3 September 2015, at 14:28.
    Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?
Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?
Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

v
Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

v
Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?
Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

vProgramming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?


Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

Programming Assignment: Webserver
P538 Computer Networks
Assigned: 9/6/2015
Due: 9/20/2015 at 11:59 pm
Instructions:
• You may discuss with your classmate, but please submit your own individual assignment.
• Please submit your code via Canvas
• If you have debug statements, please remove them or comment them out before
submitting.
• Readability is an important part of your programming assignment. To aide readability of
your code, you should modularize your code by decomposing the programming tasks into
functions. Do not implement all code in main (). You should also comment all code.
Each function should contain comments that describe its function. There should be
comments within the function to describe the functionality that is being implemented.
• If you have debug statements, please remove them or comment them out before
submitting.
• In addition to C source code files, supply a makefile and address all compilation errors.
The purpose of this assignment is for you to learn the basics of socket programming for TCP
connections: how to create a socket, bind it to a specific address and port, as well as send and
receive a HTTP packet. You will also learn some basics of HTTP header format.
Part I: Webserver
Develop a web server that handles one HTTP request at a time. Your web server should accept
and parse the HTTP request, get the requested file from the server’s file system, create an HTTP
response message consisting of the requested file preceded by header lines, and then send the
response directly to the client. If the requested file is not present in the server, the server should
send an HTTP “404 Not Found” message back to the client. Your servers should also implement
the response “400: Bad Request”, which indicates that the request message was not understood
by the server. Your server should support non-persistent and persistent connections.
Running your Webserver
Put an HTML file (e.g., HelloWorld.html) in the same directory that the server is in. Run the
server program. Determine the IP address of the host that is running the server (e.g.,
128.238.251.26). From another host, open a browser and provide the corresponding URL. For
example:http://128.238.251.26:6789/HelloWorld.html
‘HelloWorld.html’ is the name of the file you placed in the server directory. Note also the use of
the port number after the colon. You need to replace this port number with whatever port you
have used in the server code. In the above example, we have used the port number 6789. The
browser should then display the contents of HelloWorld.html. If you omit ":6789", the browser
will assume port 80 and you will get the web page from the server only if your server is listening
at port 80.
Then try to get a file that is not present at the server. You should get a “404 Not Found”
message.
Part II. Web Client
Instead of using a browser, write your own HTTP client to test your server. Your client will
connect to the server using a TCP connection, send an HTTP request to the server, and display
the server response as an output. Your client must implement the Get and use the “Close” option
to indicate that the connection is non-persistent. can assume that the HTTP request sent is a GET
method. Your client should request a basic text file, .txt. Once that file has been received, the
client should print the file to stdout.
The client should take command line arguments specifying the server IP address or host name,
the port at which the server is listening, whether the connection is non-persistent or persistent,
and the path at which the requested object is stored at the server. The following is an input
command format to run the client.
client server_host server_port connection_type filename.txt
The connection type may be specified as “np” for non-persistent and “p” for persistent. For non-
persistent connections, filename.txt indicates the name of the file that will be retrieved from the
server. When connection type is specified to be persistent, filename.txt is assumed to be a file
that contains a list of filenames that will be retrieved from the server. The format of filename.txt
for the latter case is one filename per line.
Part III. Connection-less, Unreliable client and server
Write a new version of your client and server applications using UDP sockets. Your client
should implement a HTTP Get request and record the number of bytes that it receives. The
server should process the Get and indicate when the last byte of the file has been transmitted.Part IV: Multi-threaded Server
Currently, the web server handles only one HTTP request at a time. Using Pthreads, implement a
multithreaded server that is capable of serving multiple requests simultaneously. Using
threading, first create a main thread in which your modified server listens for clients at a fixed
port. When it receives a TCP connection request from a client, it will set up the TCP connection
through another port and services the client request in a separate thread. There will be a separate
TCP connection in a separate thread for each request/response pair.
http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html
Part V: Write-up
Your write-up should include an analysis of the time that it takes for your client to receive
requested files in various scenarios. You should use the “gettimeofday” function that is included
in the standard c library <sys/time.h> to take time measurements. Gettimeofday provides timing
data at the granularity of microseconds, but note that you may need to check the resolution of the
clock at the operating system to ensure that microseconds is achievable. In addition to timing
getting timing data within the code, you should use Wireshark to provide evidence of packets
being transmitted between your client and server. Your write-up should include Wireshark
screenshots to support your analysis.
Test your client and server applications on the CS machines. Compare and contrast the time that
it takes to request and receive one to ten 1 MB text files using non-persistent and persistent
connections. Explain the trends that you observe. What is the expected RTT in this
environment? Does the time taken to service multiple requests grow linearly? Why or Why not?
Using your connection client and server, how long does it take to request and receive a 1 MB
file? How does this time compare to the times for persistent and non-persistent connections?
Complete the same analysis for the multi-threaded server. In addition, your analysis should
discuss the performance received using the UDP client and server applications. Do you
experience packet loss when using your UDP client and server applications? If so, when does
loss occur?

